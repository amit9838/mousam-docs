<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Architecture - Mousam</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">Mousam</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Home</a>
<li class="chapter" data-path="QUICKSTART/">
<a href="../QUICKSTART/">Quick Start</a>
<li class="chapter active" data-path="ARCHITECTURE/">
<a href="./">Architecture</a>
<li class="chapter" data-path="API_INTEGRATION/">
<a href="../API_INTEGRATION/">API Integration</a>
<li class="chapter" data-path="DEVELOPER/">
<a href="../DEVELOPER/">Developer Guide</a>
<li class="chapter" data-path="INTEGRATION/">
<a href="../INTEGRATION/">Integration</a>
<li class="chapter" data-path="DOCUMENTATION_INDEX/">
<a href="../DOCUMENTATION_INDEX/">Documentation Index</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="architecture-design-documentation">Architecture &amp; Design Documentation</h1>
<h2 id="in-depth-system-architecture">In-Depth System Architecture</h2>
<h3 id="1-layered-architecture-overview">1. Layered Architecture Overview</h3>
<p>Mousam follows a <strong>layered architecture</strong> pattern with clear separation of concerns:</p>
<pre><code>┌──────────────────────────────────────────────────────────┐
│ PRESENTATION LAYER                                       │
│ ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│ │ Main Window  │  │ Dialog Views │  │ Preferences  │   │
│ └──────────────┘  └──────────────┘  └──────────────┘   │
└──────────────────────────────────────────────────────────┘
                         ▲
                         │ GTK Signals
                         │
┌──────────────────────────────────────────────────────────┐
│ BUSINESS LOGIC LAYER                                     │
│ ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│ │Weather       │  │Location      │  │Preferences   │   │
│ │Service       │  │Service       │  │Manager       │   │
│ └──────────────┘  └──────────────┘  └──────────────┘   │
└──────────────────────────────────────────────────────────┘
                         ▲
                         │
┌──────────────────────────────────────────────────────────┐
│ DATA ACCESS LAYER                                        │
│ ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│ │API Client    │  │Cache Manager │  │Config Store  │   │
│ └──────────────┘  └──────────────┘  └──────────────┘   │
└──────────────────────────────────────────────────────────┘
                         ▲
                         │
┌──────────────────────────────────────────────────────────┐
│ EXTERNAL INTERFACES                                      │
│ ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│ │Open-Meteo    │  │File System   │  │System APIs   │   │
│ │API           │  │(XDG)         │  │(D-Bus, etc)  │   │
│ └──────────────┘  └──────────────┘  └──────────────┘   │
└──────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="2-component-interaction-diagrams">2. Component Interaction Diagrams</h3>
<h4 id="current-weather-display-flow">Current Weather Display Flow</h4>
<pre><code>User Launches App
       │
       ▼
┌─────────────────┐
│MouseamApp       │ Initialize GTK
│(app.py)         │ Load resources
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│MouseamWindow    │ Create main UI
│(window.py)      │ Load settings
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────┐
│LocationService                      │
│- Load last selected location        │
│- Or use default location            │
└────────┬────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────┐
│WeatherService.get_weather()         │
│ 1. Check cache validity             │
│ 2. If cache miss: fetch from API    │
│ 3. Validate and transform data      │
│ 4. Return Weather model             │
└────────┬────────────────────────────┘
         │
         ├─────────────────────────────┐
         │                             │
         ▼                             ▼
    Cache Hit?               Cache Miss?
         │                        │
         ▼                        ▼
    Return from            ┌──────────────┐
    Cache                  │APIClient     │
         │                 │.fetch()      │
         │                 │- HTTP req    │
         │                 │- Parse JSON  │
         │                 └──────┬───────┘
         │                        │
         │        ┌───────────────┤
         │        │               │
         │        ▼               ▼
         │    Success?        Error
         │        │             │
         │        ▼             ▼
         │     Store in    Fallback to
         │     Cache       Stale Cache
         │        │             │
         └────────┴─────────────┘
                  │
                  ▼
         ┌────────────────────┐
         │Transform to Models │
         │- Current Weather   │
         │- Hourly Forecast   │
         │- Daily Forecast    │
         └────────┬───────────┘
                  │
                  ▼
         ┌────────────────────┐
         │Update UI Components│
         │- Temperature card  │
         │- Metrics display   │
         │- Forecast charts   │
         └────────┬───────────┘
                  │
                  ▼
         Display Weather


</code></pre>
<h4 id="api-call-detail">API Call Detail</h4>
<pre><code>APIClient.fetch_forecast()
│
├─ Build URL
│  url = &quot;https://api.open-meteo.com/v1/forecast&quot;
│  params = {
│    &quot;latitude&quot;: 28.6139,
│    &quot;longitude&quot;: 77.2090,
│    &quot;hourly&quot;: &quot;temperature_2m,precipitation,...&quot;
│    &quot;daily&quot;: &quot;temperature_2m_max,...&quot;
│    &quot;timezone&quot;: &quot;Asia/Kolkata&quot;
│  }
│
├─ Execute Request
│  try:
│    response = requests.get(url, params=params, timeout=10)
│  except requests.Timeout:
│    retry_with_backoff()  # Exponential backoff
│
├─ Parse Response
│  {
│    &quot;latitude&quot;: 28.6139,
│    &quot;hourly&quot;: {
│      &quot;time&quot;: [&quot;2025-01-01T00:00&quot;, ...],
│      &quot;temperature_2m&quot;: [25.5, 24.3, ...],
│      &quot;precipitation&quot;: [0, 0.1, ...],
│      ...
│    },
│    &quot;daily&quot;: {
│      &quot;temperature_2m_max&quot;: [32, 31, ...],
│      &quot;temperature_2m_min&quot;: [18, 17, ...],
│      ...
│    }
│  }
│
└─ Return to Caller
   weather_data = response.json()
</code></pre>
<h3 id="3-state-management">3. State Management</h3>
<h4 id="application-state-lifecycle">Application State Lifecycle</h4>
<pre><code>START
  │
  ├─ Load User Settings
  │  └─ Cache TTL config
  │  └─ Temperature unit preference
  │  └─ Saved locations
  │
  ├─ Initialize Services
  │  ├─ WeatherService
  │  ├─ LocationService
  │  ├─ CacheManager
  │  └─ PreferencesManager
  │
  ├─ Show Main Window
  │  ├─ Restore window size/position
  │  ├─ Load last selected location
  │  └─ Fetch initial weather
  │
  ├─ EVENT LOOP
  │  ├─ Handle User Input
  │  │  ├─ Location change → Fetch new weather
  │  │  ├─ Units toggle → Refresh display
  │  │  ├─ Refresh click → Force API call
  │  │  └─ Settings change → Update app behavior
  │  │
  │  ├─ Handle Async Operations
  │  │  ├─ API responses → Update UI
  │  │  ├─ Cache updates → Persist to disk
  │  │  └─ Timer events → Periodic refresh
  │  │
  │  └─ Handle System Events
  │     ├─ Network state change
  │     ├─ System time change
  │     └─ Theme preference change
  │
  └─ SHUTDOWN
     ├─ Save window state
     ├─ Save current location
     ├─ Cleanup resources
     └─ Exit cleanly
</code></pre>
<h3 id="4-data-flow-patterns">4. Data Flow Patterns</h3>
<h4 id="pattern-1-synchronous-data-retrieval-cached">Pattern 1: Synchronous Data Retrieval (Cached)</h4>
<pre><code>Request Weather
    │
    ▼
CacheManager.get(location_id)
    │
    ├─ Cache Hit (fresh) ──────────────► Return cached data
    │                                          │
    │                                          ▼
    │                                    Update UI immediately
    │                                          │
    │                                    (Background refresh)
    │                                          │
    │                                    └──────┐
    └─ Cache Miss ────────────────────────────┘
        │
        ▼
    APIClient.fetch()
        │
        ├─ Success ──► Parse ──► Store in cache ──► Update UI
        │
        └─ Failure
            │
            ├─ Expired cache? ──► Show with warning
            └─ No cache? ──► Show error dialog
</code></pre>
<h4 id="pattern-2-async-background-update">Pattern 2: Async Background Update</h4>
<pre><code>Timer fires (30 min interval)
    │
    ▼
Emit &quot;time_to_refresh&quot; signal
    │
    ▼
Create background thread
    │
    ├─ Main thread: Continue responsive
    │
    └─ Worker thread:
        │
        ├─ Fetch fresh data
        │
        ├─ Update cache
        │
        └─ Emit &quot;data_ready&quot; signal
           │
           ▼
        Back to main thread
        (via GLib.idle_add)
           │
           ▼
        Update UI
</code></pre>
<h3 id="5-service-architecture-details">5. Service Architecture Details</h3>
<h4 id="weatherservice">WeatherService</h4>
<pre><code>class WeatherService:
    &quot;&quot;&quot;Orchestrates weather data retrieval and caching&quot;&quot;&quot;

    - api_client: APIClient
    - cache_manager: CacheManager
    - location_service: LocationService

    Methods:

    async get_weather(location: Location) -&gt; Weather:
        &quot;&quot;&quot;
        Fetches weather, using cache if available.

        Flow:
        1. Build cache key from location ID
        2. Check cache.get(key)
        3. If fresh: return cached
        4. Else: call API
        5. Transform API response
        6. Update cache
        7. Return weather data
        &quot;&quot;&quot;

    async refresh_weather(location: Location) -&gt; Weather:
        &quot;&quot;&quot;
        Force refresh from API, bypass cache.

        Used when:
        - User clicks refresh button
        - Manual update requested
        - Cache explicitly cleared
        &quot;&quot;&quot;

    async get_hourly_forecast(location: Location, hours: int) -&gt; HourlyForecast:
        &quot;&quot;&quot;Get detailed hourly breakdown&quot;&quot;&quot;

    async get_daily_forecast(location: Location, days: int) -&gt; List[DailyForecast]:
        &quot;&quot;&quot;Get daily weather summary&quot;&quot;&quot;
</code></pre>
<h4 id="cachemanager">CacheManager</h4>
<pre><code>class CacheManager:
    &quot;&quot;&quot;Manages local weather data persistence&quot;&quot;&quot;

    Storage structure:
    ~/.config/mousam/cache/
    ├── weather_cache.json       # Current and hourly
    └── forecast_cache.json      # Daily forecasts

    Cache Entry Format:
    {
        &quot;location_id&quot;: &quot;28.6139_77.2090&quot;,
        &quot;data&quot;: { ... weather data ... },
        &quot;timestamp&quot;: 1700000000,
        &quot;ttl&quot;: 1800,  # 30 minutes
        &quot;is_expired&quot;: false
    }

    Methods:

    def get(key: str) -&gt; Optional[Dict]:
        &quot;&quot;&quot;
        Check if cached data is fresh

        1. Load from disk
        2. Calculate age
        3. Compare to TTL
        4. Mark if expired
        5. Return if valid
        &quot;&quot;&quot;

    def set(key: str, data: Dict, ttl: int = 1800):
        &quot;&quot;&quot;Store data with TTL&quot;&quot;&quot;

    def is_expired(timestamp: float, ttl: int) -&gt; bool:
        &quot;&quot;&quot;Check if cache entry passed TTL&quot;&quot;&quot;

    def clear_all():
        &quot;&quot;&quot;Clear all cached data&quot;&quot;&quot;

    def cleanup_expired():
        &quot;&quot;&quot;Remove old expired entries&quot;&quot;&quot;
</code></pre>
<h4 id="locationservice">LocationService</h4>
<pre><code>class LocationService:
    &quot;&quot;&quot;Manages location selection and geolocation&quot;&quot;&quot;

    Methods:

    def get_saved_locations() -&gt; List[Location]:
        &quot;&quot;&quot;Load user's saved locations from disk&quot;&quot;&quot;

    def save_location(location: Location) -&gt; bool:
        &quot;&quot;&quot;Persist location to storage&quot;&quot;&quot;

    def search_locations(query: str) -&gt; List[Location]:
        &quot;&quot;&quot;
        Search for locations by name

        Uses Open-Meteo Geocoding API:
        GET /geocoding?name=New%20York

        Returns:
        [
            {
                &quot;id&quot;: 5128581,
                &quot;name&quot;: &quot;New York&quot;,
                &quot;latitude&quot;: 40.7128,
                &quot;longitude&quot;: -74.0060,
                &quot;country&quot;: &quot;United States&quot;,
                &quot;timezone&quot;: &quot;America/New_York&quot;
            },
            ...
        ]
        &quot;&quot;&quot;

    def get_current_location() -&gt; Optional[Location]:
        &quot;&quot;&quot;
        Get device's current location

        Attempts (in order):
        1. Last saved location
        2. Geolocation API (if permitted)
        3. Default fallback location
        &quot;&quot;&quot;
</code></pre>
<h3 id="6-error-handling-strategy">6. Error Handling Strategy</h3>
<h4 id="exception-hierarchy">Exception Hierarchy</h4>
<pre><code>MouseamError (base)
├── APIError
│   ├── NetworkError
│   │   ├── ConnectionTimeout
│   │   ├── ConnectionRefused
│   │   └── DNSResolutionError
│   ├── HTTPError
│   │   ├── ClientError (4xx)
│   │   ├── ServerError (5xx)
│   │   └── RateLimitError
│   └── DataParseError
├── CacheError
│   ├── CacheCorrupted
│   ├── CacheWriteFailed
│   └── InvalidCacheEntry
├── LocationError
│   ├── LocationNotFound
│   └── GeolocationDenied
└── ConfigError
    ├── SettingsCorrupted
    └── PermissionDenied
</code></pre>
<h4 id="error-recovery-strategies">Error Recovery Strategies</h4>
<pre><code>APIError
  │
  ├─ NetworkError
  │  ├─ Retry with exponential backoff
  │  │  (1s, 2s, 4s, 8s)
  │  │
  │  └─ After 3 failures:
  │     ├─ Use cached data if available
  │     ├─ Display offline indicator
  │     └─ Show &quot;Retry&quot; button
  │
  ├─ RateLimitError (429)
  │  ├─ Wait and retry
  │  │  (Extract Retry-After header)
  │  │
  │  └─ Queue request for later
  │
  └─ DataParseError
     ├─ Log error details
     ├─ Use fallback data
     └─ Alert user to app issue

CacheError
  └─ Attempt auto-recovery:
     ├─ Rebuild cache from API
     ├─ If fails: disable caching
     └─ Continue with live data only
</code></pre>
<h3 id="7-threading-concurrency">7. Threading &amp; Concurrency</h3>
<h4 id="thread-model">Thread Model</h4>
<pre><code>Main Thread (GTK Event Loop)
│
├─ Handles all UI updates
├─ Processes user input
├─ Runs GTK signal handlers
└─ Triggers worker threads

Worker Threads (for I/O operations)
│
├─ APIClient.fetch()
│  │ (Network I/O - non-blocking)
│  └─ Result → GLib.idle_add() → Main thread
│
├─ CacheManager.read/write()
│  │ (Disk I/O - non-blocking)
│  └─ Result → GLib.idle_add() → Main thread
│
└─ LocationService.search()
   │ (Network I/O - non-blocking)
   └─ Result → GLib.idle_add() → Main thread

Critical: Never call GTK functions from worker threads!
Use: GLib.idle_add(func, arg) to queue back to main thread
</code></pre>
<h4 id="concurrency-pattern">Concurrency Pattern</h4>
<pre><code class="language-python">def on_refresh_button_clicked(self):
    &quot;&quot;&quot;Handle refresh button - non-blocking&quot;&quot;&quot;

    # Start background task
    thread = threading.Thread(
        target=self._fetch_weather_async,
        daemon=True
    )
    thread.start()

    # Main thread continues immediately
    self.show_loading_indicator()

def _fetch_weather_async(self):
    &quot;&quot;&quot;Run in background, never touch UI directly&quot;&quot;&quot;

    try:
        weather = self.service.fetch_weather(
            self.current_location
        )

        # Queue UI update back to main thread
        GLib.idle_add(
            self._update_weather_ui,
            weather
        )

    except APIError as e:
        GLib.idle_add(
            self._show_error_dialog,
            str(e)
        )

def _update_weather_ui(self, weather):
    &quot;&quot;&quot;Called in main thread - safe to update UI&quot;&quot;&quot;
    self.temperature_label.set_text(
        f&quot;{weather.current.temp}°C&quot;
    )
</code></pre>
<h3 id="8-memory-management">8. Memory Management</h3>
<h4 id="resource-lifecycle">Resource Lifecycle</h4>
<pre><code>Application Start
    │
    ├─ Load Resources
    │  ├─ .gresource (UI files, icons, CSS)
    │  ├─ Configuration files
    │  └─ Theme assets
    │
    ├─ Cache Loaded Data
    │  ├─ Recent locations (in memory)
    │  ├─ User preferences (in memory)
    │  └─ Weather data (in memory)
    │
    └─ Create UI Objects
       ├─ Main window
       ├─ GTK widgets
       └─ Signal handlers

Runtime Memory Usage:
- Current weather object: ~1-2 MB
- Forecast data (hourly): ~2-3 MB
- Daily forecast: ~0.5 MB
- UI elements: ~5-10 MB
- Total resident: ~20-30 MB

Application Shutdown
    │
    ├─ Disconnect signals
    ├─ Cleanup resources
    ├─ Save application state
    └─ Exit GTK main loop
</code></pre>
<hr />
<h2 id="design-patterns-used">Design Patterns Used</h2>
<h3 id="1-model-view-controller-mvc">1. Model-View-Controller (MVC)</h3>
<pre><code>Model (Data Layer):
- Weather, Location, Forecast dataclasses
- Represent domain entities
- No UI or business logic

View (Presentation Layer):
- GTK widgets and windows
- Display data
- Generate signals from user input

Controller (Business Logic):
- WeatherService, LocationService
- Process user actions
- Update models
- Notify views of changes
</code></pre>
<h3 id="2-dependency-injection">2. Dependency Injection</h3>
<pre><code class="language-python"># Example: Services are injected
class MouseamWindow(Gtk.ApplicationWindow):
    def __init__(self, weather_service, location_service):
        self.weather_service = weather_service
        self.location_service = location_service

        # Services can be mocked for testing
        # Decouples components
        # Easy to extend
</code></pre>
<h3 id="3-observer-pattern">3. Observer Pattern</h3>
<pre><code class="language-python"># GTK signals implement observer pattern
self.location_combo.connect(
    &quot;changed&quot;,  # Signal name
    self.on_location_changed  # Observer method
)

# When location changes, callback is invoked
def on_location_changed(self, combo):
    &quot;&quot;&quot;Observer gets notified of change&quot;&quot;&quot;
    self.fetch_weather_for_selected_location()
</code></pre>
<h3 id="4-singleton-pattern">4. Singleton Pattern</h3>
<pre><code class="language-python">class CacheManager:
    &quot;&quot;&quot;Ensure only one instance exists&quot;&quot;&quot;
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    # Single shared cache across app
</code></pre>
<h3 id="5-repository-pattern">5. Repository Pattern</h3>
<pre><code class="language-python">class SettingsRepository:
    &quot;&quot;&quot;Abstraction for configuration storage&quot;&quot;&quot;

    def save(self, key: str, value: Any):
        &quot;&quot;&quot;Could use JSON, GSettings, DB, etc.&quot;&quot;&quot;
        pass

    def load(self, key: str) -&gt; Any:
        &quot;&quot;&quot;Implementation detail hidden&quot;&quot;&quot;
        pass
</code></pre>
<h3 id="6-async-task-pattern">6. Async Task Pattern</h3>
<pre><code class="language-python">def execute_async(func, callback):
    &quot;&quot;&quot;
    Run long operation without blocking UI

    - func: Long-running function
    - callback: Called when complete
    &quot;&quot;&quot;
    thread = threading.Thread(target=func)
    thread.daemon = True
    thread.start()

    # Result passed to callback in main thread
</code></pre>
<hr />
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="optimization-techniques">Optimization Techniques</h3>
<h4 id="1-caching">1. Caching</h4>
<p><strong>Multi-level caching strategy:</strong>
- <strong>Memory cache</strong>: Current request results
- <strong>Disk cache</strong>: Persistent across sessions
- <strong>API cache</strong>: Server-side response caching</p>
<pre><code class="language-python"># Check before API call
cached = cache.get(location_key)
if cached and not cached.is_expired():
    return cached_data  # Instant response

# Otherwise fetch
fresh_data = api.fetch()
cache.set(location_key, fresh_data)
</code></pre>
<h4 id="2-lazy-loading">2. Lazy Loading</h4>
<pre><code class="language-python"># Don't fetch 7-day forecast until user clicks tab
class DailyForecastPage:
    def __init__(self):
        self.forecast_data = None

    def on_page_visible(self):
        &quot;&quot;&quot;Only load when actually needed&quot;&quot;&quot;
        if self.forecast_data is None:
            self.fetch_forecast()
</code></pre>
<h4 id="3-data-pagination">3. Data Pagination</h4>
<pre><code class="language-python"># Load hourly forecast in chunks
class HourlyChart:
    def load_next_hours(self, count=6):
        &quot;&quot;&quot;Load next 6 hours of data&quot;&quot;&quot;
        # Reduces memory usage
        # Smoother scrolling
</code></pre>
<h4 id="4-ui-virtualization">4. UI Virtualization</h4>
<pre><code class="language-python"># Only render visible rows
class DailyForecastList(Gtk.ListView):
    # GTK4 automatically virtualizes list items
    # Only visible items are rendered
    # Saves memory for large lists
</code></pre>
<h3 id="memory-profiling">Memory Profiling</h3>
<pre><code class="language-bash"># Monitor memory usage
python3 -m memory_profiler src/mousam/__main__.py

# Profile specific functions
@profile
def fetch_weather():
    # Function marked for profiling
    pass
</code></pre>
<h3 id="performance-benchmarks">Performance Benchmarks</h3>
<pre><code>Operation                  Time        Notes
─────────────────────────────────────────────────
App startup                ~500ms      (first time)
Location search (10 chars)  ~200ms      network call
Weather fetch (cached)      ~50ms       memory access
Weather fetch (API)         ~1-2s       network + processing
Theme switch                ~100ms      CSS recomputation
Forecast chart render       ~300ms      Cairo drawing
</code></pre>
<hr />
<h2 id="security-considerations">Security Considerations</h2>
<h3 id="input-validation">Input Validation</h3>
<pre><code class="language-python"># Sanitize location search input
def search_locations(query: str) -&gt; List[Location]:
    # Validate input
    if not query or len(query) &gt; 200:
        raise ValidationError(&quot;Invalid search query&quot;)

    # Sanitize before API call
    safe_query = urllib.parse.quote(query)

    # Make API request
    return api.search(safe_query)
</code></pre>
<h3 id="api-security">API Security</h3>
<pre><code class="language-python"># Always use HTTPS for API calls
api_url = &quot;https://api.open-meteo.com/v1/forecast&quot;
# Never http://

# Timeout to prevent hanging
response = requests.get(
    api_url,
    timeout=10  # 10 second timeout
)

# Validate response
if response.status_code not in [200, 204]:
    raise APIError(f&quot;HTTP {response.status_code}&quot;)
</code></pre>
<h3 id="data-privacy">Data Privacy</h3>
<ul>
<li><strong>No user tracking</strong>: Mousam doesn't collect personal data</li>
<li><strong>Local storage only</strong>: Settings and cache stored locally</li>
<li><strong>No analytics</strong>: No telemetry or usage reporting</li>
<li><strong>API calls</strong>: Only to Open-Meteo for weather data</li>
<li>Location coordinates sent only to fetch weather</li>
<li>No user ID or tracking information</li>
</ul>
<h3 id="xss-prevention-for-web-version">XSS Prevention (for web version)</h3>
<pre><code class="language-python"># Escape HTML special characters
def safe_display_text(text: str) -&gt; str:
    return (
        text
        .replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
        .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
        .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
        .replace('&quot;', &quot;&amp;quot;&quot;)
    )
</code></pre>
<hr />
<h2 id="scalability-extensibility">Scalability &amp; Extensibility</h2>
<h3 id="adding-new-weather-metrics">Adding New Weather Metrics</h3>
<pre><code class="language-python"># Step 1: Update data model
@dataclass
class CurrentWeather:
    temperature: float
    humidity: int
    air_quality_index: int  # New field

# Step 2: Update API client
def fetch_forecast(self, lat, lon):
    hourly_vars = [
        &quot;temperature_2m&quot;,
        &quot;relative_humidity_2m&quot;,
        &quot;air_quality&quot;,  # New variable
    ]
    return self.api_call(hourly=hourly_vars)

# Step 3: Create UI widget
class AirQualityCard(Gtk.Box):
    def set_data(self, aqi: int):
        self.value_label.set_text(f&quot;AQI: {aqi}&quot;)
        self.set_color_from_aqi(aqi)

# Step 4: Update main window
class MouseamWindow:
    def __init__(self):
        self.aqi_card = AirQualityCard()
        self.main_box.append(self.aqi_card)

    def update_weather_display(self, weather):
        self.aqi_card.set_data(
            weather.current.air_quality_index
        )
</code></pre>
<h3 id="supporting-alternative-apis">Supporting Alternative APIs</h3>
<pre><code class="language-python"># Abstract API client
class WeatherAPIClient(ABC):
    @abstractmethod
    def fetch_forecast(self, lat, lon):
        pass

# Implementations
class OpenMeteoClient(WeatherAPIClient):
    def fetch_forecast(self, lat, lon):
        # Open-Meteo specific
        pass

class WeatherAPIClient(WeatherAPIClient):
    def fetch_forecast(self, lat, lon):
        # Weather API specific
        pass

# Switch via configuration
api_client = (
    OpenMeteoClient()
    if config.API_PROVIDER == &quot;openmeteo&quot;
    else WeatherAPIClient()
)
</code></pre>
<hr />
<h2 id="testing-strategy">Testing Strategy</h2>
<h3 id="unit-testing">Unit Testing</h3>
<pre><code class="language-python"># Test weather service
class TestWeatherService:
    def test_get_weather_returns_valid_model(self):
        service = WeatherService(
            api_client=MockAPIClient(),
            cache=MockCache()
        )
        weather = service.get_weather(
            Location(&quot;Delhi&quot;, 28.6, 77.2)
        )
        assert weather.current.temperature &gt; -100
        assert weather.current.temperature &lt; 150

    def test_cache_hit_returns_cached_data(self):
        service = WeatherService(
            api_client=MockAPIClient(calls=0),
            cache=MockCache(returns_valid=True)
        )
        # Should not call API
        service.get_weather(location)
        assert service.api_client.calls == 0
</code></pre>
<h3 id="integration-testing">Integration Testing</h3>
<pre><code class="language-python"># Test API integration
class TestAPIIntegration:
    def test_fetch_real_forecast(self):
        client = APIClient()
        result = client.fetch_forecast(28.6, 77.2)

        # Validate response structure
        assert &quot;hourly&quot; in result
        assert &quot;daily&quot; in result
        assert &quot;latitude&quot; in result
</code></pre>
<h3 id="ui-testing">UI Testing</h3>
<pre><code class="language-bash"># Use GTK test utilities
GTK_DEBUG=interactive mousam  # Opens inspector

# Accessibility testing
accerciser  # GTK accessibility inspector
</code></pre>
<hr />
<h2 id="deployment-distribution">Deployment &amp; Distribution</h2>
<h3 id="build-configuration">Build Configuration</h3>
<pre><code class="language-meson"># meson.build structure
project('mousam', 'python',
  version: '1.4.0',
  description: 'Weather at a glance',
)

# Python module
py = import('python')
py_installation = py.find_installation('python3', ...)

# Define install directories
install_dir = py.get_install_dir()
data_dir = get_option('datadir')
locale_dir = get_option('localedir')

# Install application
install_subdir('src/mousam', install_dir: install_dir)
install_subdir('data/icons', install_dir: data_dir)
</code></pre>
<h3 id="flatpak-manifest">Flatpak Manifest</h3>
<pre><code class="language-yaml">app-id: io.github.amit9838.mousam
runtime: org.gnome.Platform
runtime-version: '46'

modules:
  - name: mousam
    buildsystem: meson
    sources:
      - type: git
        url: https://github.com/amit9838/mousam.git
</code></pre>
<hr />
<p><strong>This architecture ensures Mousam is maintainable, scalable, and follows industry best practices for desktop application development.</strong></p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>
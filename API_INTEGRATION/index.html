<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>API Integration - Mousam</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">Mousam</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Home</a>
<li class="chapter" data-path="QUICKSTART/">
<a href="../QUICKSTART/">Quick Start</a>
<li class="chapter" data-path="ARCHITECTURE/">
<a href="../ARCHITECTURE/">Architecture</a>
<li class="chapter active" data-path="API_INTEGRATION/">
<a href="./">API Integration</a>
<li class="chapter" data-path="DEVELOPER/">
<a href="../DEVELOPER/">Developer Guide</a>
<li class="chapter" data-path="INTEGRATION/">
<a href="../INTEGRATION/">Integration</a>
<li class="chapter" data-path="DOCUMENTATION_INDEX/">
<a href="../DOCUMENTATION_INDEX/">Documentation Index</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="api-integration-documentation">API &amp; Integration Documentation</h1>
<h2 id="open-meteo-weather-api-integration">Open-Meteo Weather API Integration</h2>
<h3 id="overview">Overview</h3>
<p>Mousam integrates with the <strong>Open-Meteo API</strong>, a free, open-source weather API that provides global weather forecasts without requiring authentication.</p>
<p><strong>API Endpoint</strong>: <code>https://api.open-meteo.com/v1/</code></p>
<p><strong>Key Features</strong>:
- No authentication required
- Free for non-commercial use
- Global coverage (11km global model + 1km local models)
- Hourly and daily resolution forecasts
- Up to 16-day forecast range
- Historical data available</p>
<hr />
<h2 id="api-endpoints-used">API Endpoints Used</h2>
<h3 id="1-forecast-endpoint">1. Forecast Endpoint</h3>
<p>Returns weather forecast data for a specific location.</p>
<p><strong>Endpoint</strong>: <code>GET /forecast</code></p>
<h4 id="request-parameters">Request Parameters</h4>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>latitude</code></td>
<td>float</td>
<td>Yes</td>
<td>-</td>
<td>Latitude (-90 to 90)</td>
</tr>
<tr>
<td><code>longitude</code></td>
<td>float</td>
<td>Yes</td>
<td>-</td>
<td>Longitude (-180 to 180)</td>
</tr>
<tr>
<td><code>hourly</code></td>
<td>string</td>
<td>No</td>
<td>-</td>
<td>Comma-separated hourly variables</td>
</tr>
<tr>
<td><code>daily</code></td>
<td>string</td>
<td>No</td>
<td>-</td>
<td>Comma-separated daily variables</td>
</tr>
<tr>
<td><code>temperature_unit</code></td>
<td>string</td>
<td>No</td>
<td>celsius</td>
<td>Temperature scale (celsius/fahrenheit)</td>
</tr>
<tr>
<td><code>windspeed_unit</code></td>
<td>string</td>
<td>No</td>
<td>kmh</td>
<td>Wind speed unit (kmh/mph/ms/kn)</td>
</tr>
<tr>
<td><code>timezone</code></td>
<td>string</td>
<td>No</td>
<td>UTC</td>
<td>IANA timezone string (e.g., Asia/Kolkata)</td>
</tr>
</tbody>
</table>
<h4 id="response-structure">Response Structure</h4>
<pre><code class="language-json">{
  &quot;latitude&quot;: 28.6139,
  &quot;longitude&quot;: 77.2090,
  &quot;generationtime_ms&quot;: 156.3,
  &quot;utc_offset_seconds&quot;: 19800,
  &quot;timezone&quot;: &quot;Asia/Kolkata&quot;,
  &quot;timezone_abbreviation&quot;: &quot;IST&quot;,
  &quot;elevation&quot;: 216.0,

  &quot;hourly&quot;: {
    &quot;time&quot;: [&quot;2025-01-01T00:00&quot;, &quot;2025-01-01T01:00&quot;, ...],
    &quot;temperature_2m&quot;: [25.5, 24.3, 23.8, ...],
    &quot;relative_humidity_2m&quot;: [60, 65, 70, ...],
    &quot;precipitation&quot;: [0.0, 0.0, 0.1, ...],
    &quot;weather_code&quot;: [0, 0, 3, ...],
    &quot;wind_speed_10m&quot;: [5.2, 4.8, 6.1, ...],
    &quot;wind_direction_10m&quot;: [180, 175, 190, ...],
    &quot;uv_index&quot;: [0.0, 0.0, 0.5, ...],
    &quot;cloud_cover&quot;: [10, 15, 25, ...]
  },

  &quot;daily&quot;: {
    &quot;time&quot;: [&quot;2025-01-01&quot;, &quot;2025-01-02&quot;, ...],
    &quot;temperature_2m_max&quot;: [32.1, 31.8, 30.5, ...],
    &quot;temperature_2m_min&quot;: [18.2, 17.8, 19.1, ...],
    &quot;precipitation_sum&quot;: [0.0, 0.3, 1.5, ...],
    &quot;weather_code&quot;: [0, 3, 61, ...],
    &quot;wind_speed_10m_max&quot;: [8.5, 9.2, 7.8, ...]
  },

  &quot;current_units&quot;: {
    &quot;temperature&quot;: &quot;°C&quot;,
    &quot;windspeed&quot;: &quot;km/h&quot;
  }
}
</code></pre>
<h4 id="example-request">Example Request</h4>
<pre><code class="language-bash">curl -G &quot;https://api.open-meteo.com/v1/forecast&quot; \
  --data-urlencode &quot;latitude=28.6139&quot; \
  --data-urlencode &quot;longitude=77.2090&quot; \
  --data-urlencode &quot;hourly=temperature_2m,precipitation,weather_code,wind_speed_10m,cloud_cover&quot; \
  --data-urlencode &quot;daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weather_code&quot; \
  --data-urlencode &quot;temperature_unit=celsius&quot; \
  --data-urlencode &quot;timezone=Asia/Kolkata&quot;
</code></pre>
<h4 id="weather-codes-wmo">Weather Codes (WMO)</h4>
<table>
<thead>
<tr>
<th>Code</th>
<th>Condition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Clear sky</td>
<td>Sunny, no clouds</td>
</tr>
<tr>
<td>1-3</td>
<td>Mainly clear</td>
<td>Some clouds but mostly clear</td>
</tr>
<tr>
<td>45-48</td>
<td>Foggy</td>
<td>Fog or mist</td>
</tr>
<tr>
<td>51-67</td>
<td>Drizzle/Rain</td>
<td>Light to moderate precipitation</td>
</tr>
<tr>
<td>71-77</td>
<td>Snow</td>
<td>Snow events</td>
</tr>
<tr>
<td>80-82</td>
<td>Rain showers</td>
<td>Sudden rain</td>
</tr>
<tr>
<td>85-86</td>
<td>Snow showers</td>
<td>Sudden snow</td>
</tr>
<tr>
<td>95-99</td>
<td>Thunderstorm</td>
<td>Thunderstorm with hail</td>
</tr>
</tbody>
</table>
<h3 id="2-geocoding-endpoint">2. Geocoding Endpoint</h3>
<p>Search for locations by name or get coordinates for a location.</p>
<p><strong>Endpoint</strong>: <code>GET /geocoding?name=query</code></p>
<h4 id="request-parameters_1">Request Parameters</h4>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>string</td>
<td>Yes</td>
<td>Location name to search (min 1 character)</td>
</tr>
<tr>
<td><code>count</code></td>
<td>integer</td>
<td>No</td>
<td>Number of results (default: 10)</td>
</tr>
<tr>
<td><code>language</code></td>
<td>string</td>
<td>No</td>
<td>Language code for results</td>
</tr>
</tbody>
</table>
<h4 id="response-structure_1">Response Structure</h4>
<pre><code class="language-json">{
  &quot;results&quot;: [
    {
      &quot;id&quot;: 1252431,
      &quot;name&quot;: &quot;New York&quot;,
      &quot;latitude&quot;: 40.7128,
      &quot;longitude&quot;: -74.0060,
      &quot;elevation&quot;: 10.0,
      &quot;feature_code&quot;: &quot;PPL&quot;,
      &quot;country_code&quot;: &quot;US&quot;,
      &quot;country&quot;: &quot;United States&quot;,
      &quot;admin1_id&quot;: 3651335,
      &quot;admin1&quot;: &quot;New York&quot;,
      &quot;timezone&quot;: &quot;America/New_York&quot;,
      &quot;population&quot;: 8336817,
      &quot;country_population&quot;: 331002651
    },
    {
      &quot;id&quot;: 5106834,
      &quot;name&quot;: &quot;New York City&quot;,
      &quot;latitude&quot;: 40.7127,
      &quot;longitude&quot;: -74.0059,
      &quot;elevation&quot;: 9.0,
      ...
    }
  ],
  &quot;generationtime_ms&quot;: 50.2
}
</code></pre>
<h4 id="example-request_1">Example Request</h4>
<pre><code class="language-bash">curl -G &quot;https://api.open-meteo.com/v1/geocoding&quot; \
  --data-urlencode &quot;name=Delhi&quot; \
  --data-urlencode &quot;count=5&quot;
</code></pre>
<hr />
<h2 id="implementation-in-mousam">Implementation in Mousam</h2>
<h3 id="api-client-class">API Client Class</h3>
<pre><code class="language-python"># services/api_client.py

class APIClient:
    &quot;&quot;&quot;Handles all Open-Meteo API communication&quot;&quot;&quot;

    BASE_URL = &quot;https://api.open-meteo.com/v1&quot;
    TIMEOUT = 10
    RETRIES = 3

    def fetch_forecast(self, latitude: float, longitude: float,
                      hourly_vars: List[str],
                      daily_vars: List[str],
                      timezone: str = &quot;UTC&quot;,
                      temperature_unit: str = &quot;celsius&quot;) -&gt; dict:
        &quot;&quot;&quot;
        Fetch weather forecast from Open-Meteo

        Args:
            latitude: Location latitude
            longitude: Location longitude
            hourly_vars: List of hourly variables to fetch
            daily_vars: List of daily variables to fetch
            timezone: IANA timezone string
            temperature_unit: celsius or fahrenheit

        Returns:
            dict: Raw API response

        Raises:
            APIError: On network or parsing errors

        Example:
            &gt;&gt;&gt; forecast = client.fetch_forecast(
            ...     28.6139, 77.2090,
            ...     [&quot;temperature_2m&quot;, &quot;precipitation&quot;],
            ...     [&quot;temperature_2m_max&quot;]
            ... )
        &quot;&quot;&quot;

        # Build request parameters
        params = {
            &quot;latitude&quot;: latitude,
            &quot;longitude&quot;: longitude,
            &quot;timezone&quot;: timezone,
            &quot;temperature_unit&quot;: temperature_unit,
        }

        if hourly_vars:
            params[&quot;hourly&quot;] = &quot;,&quot;.join(hourly_vars)
        if daily_vars:
            params[&quot;daily&quot;] = &quot;,&quot;.join(daily_vars)

        # Retry with exponential backoff
        for attempt in range(self.RETRIES):
            try:
                response = requests.get(
                    f&quot;{self.BASE_URL}/forecast&quot;,
                    params=params,
                    timeout=self.TIMEOUT
                )
                response.raise_for_status()
                return response.json()

            except requests.Timeout as e:
                if attempt &lt; self.RETRIES - 1:
                    wait_time = 2 ** attempt
                    time.sleep(wait_time)
                    continue
                raise APIError(f&quot;Timeout after {self.RETRIES} retries&quot;)

            except requests.RequestException as e:
                raise APIError(f&quot;Network error: {e}&quot;)

            except json.JSONDecodeError:
                raise APIError(&quot;Invalid JSON response from API&quot;)

    def search_locations(self, query: str, count: int = 10) -&gt; List[dict]:
        &quot;&quot;&quot;
        Search for locations by name

        Args:
            query: Location name to search
            count: Number of results to return

        Returns:
            List of location dictionaries

        Example:
            &gt;&gt;&gt; results = client.search_locations(&quot;Delhi&quot;, 5)
            &gt;&gt;&gt; for loc in results:
            ...     print(f&quot;{loc['name']}: {loc['latitude']}, {loc['longitude']}&quot;)
        &quot;&quot;&quot;

        try:
            response = requests.get(
                f&quot;{self.BASE_URL}/geocoding&quot;,
                params={
                    &quot;name&quot;: query,
                    &quot;count&quot;: count,
                    &quot;language&quot;: &quot;en&quot;
                },
                timeout=self.TIMEOUT
            )
            response.raise_for_status()
            data = response.json()
            return data.get(&quot;results&quot;, [])

        except requests.RequestException as e:
            raise APIError(f&quot;Location search failed: {e}&quot;)
</code></pre>
<h3 id="variables-mapping">Variables Mapping</h3>
<p><strong>Hourly Variables Fetched:</strong></p>
<pre><code class="language-python">HOURLY_VARIABLES = [
    &quot;temperature_2m&quot;,           # Current temperature at 2 meters
    &quot;relative_humidity_2m&quot;,     # Relative humidity
    &quot;apparent_temperature&quot;,     # Feels-like temperature
    &quot;precipitation&quot;,            # Precipitation amount
    &quot;weather_code&quot;,             # WMO weather code
    &quot;wind_speed_10m&quot;,          # Wind speed at 10 meters
    &quot;wind_direction_10m&quot;,      # Wind direction
    &quot;uv_index&quot;,                # UV index
    &quot;cloud_cover&quot;,             # Cloud coverage percentage
    &quot;pressure_msl&quot;,            # Mean sea level pressure
    &quot;visibility&quot;,              # Visibility distance
    &quot;wind_gusts_10m&quot;,          # Wind gust speed
]

DAILY_VARIABLES = [
    &quot;temperature_2m_max&quot;,       # Daily maximum temperature
    &quot;temperature_2m_min&quot;,       # Daily minimum temperature
    &quot;precipitation_sum&quot;,        # Daily precipitation sum
    &quot;precipitation_probability_max&quot;,  # Max precipitation probability
    &quot;weather_code&quot;,             # WMO weather code
    &quot;wind_speed_10m_max&quot;,      # Daily max wind speed
    &quot;wind_direction_10m_dominant&quot;,   # Dominant wind direction
    &quot;uv_index_max&quot;,            # Daily max UV index
    &quot;sunshine_duration&quot;,        # Hours of sunshine
]
</code></pre>
<h3 id="error-handling">Error Handling</h3>
<pre><code class="language-python">class APIError(Exception):
    &quot;&quot;&quot;Base exception for API errors&quot;&quot;&quot;
    pass

class NetworkError(APIError):
    &quot;&quot;&quot;Network connectivity error&quot;&quot;&quot;
    pass

class TimeoutError(APIError):
    &quot;&quot;&quot;Request timeout&quot;&quot;&quot;
    pass

class RateLimitError(APIError):
    &quot;&quot;&quot;API rate limit exceeded&quot;&quot;&quot;
    pass

class InvalidResponseError(APIError):
    &quot;&quot;&quot;Invalid/malformed response&quot;&quot;&quot;
    pass

# Usage in fetch_forecast:
try:
    data = client.fetch_forecast(...)
except RateLimitError:
    # Wait and retry later
    schedule_retry(delay=60)
except NetworkError:
    # Use cached data if available
    return get_cached_weather()
except APIError as e:
    # Log and show error to user
    logger.error(f&quot;API error: {e}&quot;)
    show_error_dialog(str(e))
</code></pre>
<hr />
<h2 id="caching-strategy">Caching Strategy</h2>
<h3 id="cache-structure">Cache Structure</h3>
<pre><code class="language-python"># ~/.config/mousam/cache/weather_cache.json

{
  &quot;cache_entries&quot;: {
    &quot;28.6139_77.2090&quot;: {  # Key: latitude_longitude
      &quot;location&quot;: {
        &quot;name&quot;: &quot;Delhi&quot;,
        &quot;latitude&quot;: 28.6139,
        &quot;longitude&quot;: 77.2090,
        &quot;timezone&quot;: &quot;Asia/Kolkata&quot;
      },
      &quot;data&quot;: {
        # Full forecast data
      },
      &quot;timestamp&quot;: 1704067200,  # When cached
      &quot;ttl&quot;: 1800,             # 30 minutes
      &quot;is_expired&quot;: false
    }
  }
}
</code></pre>
<h3 id="cache-implementation">Cache Implementation</h3>
<pre><code class="language-python"># services/cache.py

import json
import time
from pathlib import Path
from datetime import datetime

class CacheManager:
    &quot;&quot;&quot;Manages local weather data persistence&quot;&quot;&quot;

    def __init__(self, cache_dir: Path = None):
        if cache_dir is None:
            cache_dir = Path.home() / &quot;.config&quot; / &quot;mousam&quot; / &quot;cache&quot;

        self.cache_dir = cache_dir
        self.cache_file = cache_dir / &quot;weather_cache.json&quot;
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self._load_cache()

    def _load_cache(self):
        &quot;&quot;&quot;Load cache from disk&quot;&quot;&quot;
        if self.cache_file.exists():
            try:
                with open(self.cache_file, 'r') as f:
                    self._cache = json.load(f)
            except (json.JSONDecodeError, IOError):
                self._cache = {&quot;cache_entries&quot;: {}}
        else:
            self._cache = {&quot;cache_entries&quot;: {}}

    def get(self, location_key: str) -&gt; Optional[dict]:
        &quot;&quot;&quot;
        Retrieve cached weather if fresh

        Args:
            location_key: &quot;latitude_longitude&quot; string

        Returns:
            Weather data dict if cache hit and not expired, None otherwise

        Example:
            &gt;&gt;&gt; cached = cache.get(&quot;28.6139_77.2090&quot;)
            &gt;&gt;&gt; if cached:
            ...     print(f&quot;Using cached data from {cached['timestamp']}&quot;)
        &quot;&quot;&quot;

        if location_key not in self._cache[&quot;cache_entries&quot;]:
            return None

        entry = self._cache[&quot;cache_entries&quot;][location_key]

        # Check if expired
        age = time.time() - entry[&quot;timestamp&quot;]
        if age &gt; entry[&quot;ttl&quot;]:
            entry[&quot;is_expired&quot;] = True
            return None

        return entry[&quot;data&quot;]

    def get_with_expiry(self, location_key: str) -&gt; tuple[Optional[dict], bool]:
        &quot;&quot;&quot;
        Get cached data, including expired entries

        Returns:
            (data, is_expired) tuple

        Useful for showing stale data while refreshing
        &quot;&quot;&quot;

        if location_key not in self._cache[&quot;cache_entries&quot;]:
            return None, False

        entry = self._cache[&quot;cache_entries&quot;][location_key]
        age = time.time() - entry[&quot;timestamp&quot;]
        is_expired = age &gt; entry[&quot;ttl&quot;]

        return entry[&quot;data&quot;], is_expired

    def set(self, location_key: str, data: dict, ttl: int = 1800):
        &quot;&quot;&quot;
        Store weather data with TTL

        Args:
            location_key: &quot;latitude_longitude&quot; string
            data: Weather forecast data
            ttl: Time-to-live in seconds (default: 30 minutes)

        Example:
            &gt;&gt;&gt; cache.set(&quot;28.6139_77.2090&quot;, forecast_data)
        &quot;&quot;&quot;

        self._cache[&quot;cache_entries&quot;][location_key] = {
            &quot;data&quot;: data,
            &quot;timestamp&quot;: time.time(),
            &quot;ttl&quot;: ttl,
            &quot;is_expired&quot;: False
        }

        self._save_cache()

    def _save_cache(self):
        &quot;&quot;&quot;Persist cache to disk&quot;&quot;&quot;
        try:
            with open(self.cache_file, 'w') as f:
                json.dump(self._cache, f, indent=2)
        except IOError as e:
            logger.error(f&quot;Failed to save cache: {e}&quot;)

    def clear_all(self):
        &quot;&quot;&quot;Clear all cached entries&quot;&quot;&quot;
        self._cache = {&quot;cache_entries&quot;: {}}
        self._save_cache()

    def cleanup_expired(self):
        &quot;&quot;&quot;Remove expired cache entries&quot;&quot;&quot;
        current_time = time.time()
        expired_keys = []

        for key, entry in self._cache[&quot;cache_entries&quot;].items():
            age = current_time - entry[&quot;timestamp&quot;]
            if age &gt; entry[&quot;ttl&quot;]:
                expired_keys.append(key)

        for key in expired_keys:
            del self._cache[&quot;cache_entries&quot;][key]

        if expired_keys:
            self._save_cache()
</code></pre>
<h3 id="cache-invalidation-strategy">Cache Invalidation Strategy</h3>
<pre><code class="language-python"># When to invalidate cache:

# 1. Manual user refresh
def on_refresh_clicked():
    cache.delete(location_key)  # Force fresh fetch
    fetch_weather()

# 2. Location changed
def on_location_changed(new_location):
    # Old cache not invalidated (might return later)
    # Just fetch new location
    fetch_weather(new_location)

# 3. Settings changed (units)
def on_units_changed():
    # Cache is still valid, just display differently
    # No invalidation needed

# 4. Time-based expiration
# Automatic via TTL check in CacheManager.get()

# 5. App startup cleanup
def on_app_startup():
    cache_manager.cleanup_expired()  # Remove old entries
</code></pre>
<hr />
<h2 id="rate-limiting-throttling">Rate Limiting &amp; Throttling</h2>
<h3 id="rate-limit-handling">Rate Limit Handling</h3>
<pre><code class="language-python">class APIClient:
    def __init__(self):
        self.rate_limiter = RateLimiter(
            max_requests=60,  # 60 requests per minute
            window=60         # 1 minute window
        )

    def fetch_forecast(self, ...):
        # Check rate limit before request
        if not self.rate_limiter.allow_request():
            raise RateLimitError(
                &quot;Rate limit exceeded. Wait before retrying.&quot;
            )

        # Make request
        response = requests.get(...)

        # Check response headers for rate limit info
        if response.status_code == 429:
            retry_after = int(response.headers.get('Retry-After', 60))
            raise RateLimitError(f&quot;Wait {retry_after} seconds&quot;)

        return response.json()

class RateLimiter:
    &quot;&quot;&quot;Token bucket rate limiter&quot;&quot;&quot;

    def __init__(self, max_requests: int, window: int):
        self.max_requests = max_requests
        self.window = window
        self.requests = deque()

    def allow_request(self) -&gt; bool:
        &quot;&quot;&quot;Check if next request is allowed&quot;&quot;&quot;
        now = time.time()

        # Remove old requests outside window
        while self.requests and self.requests[0] &lt; now - self.window:
            self.requests.popleft()

        # Check if below limit
        if len(self.requests) &lt; self.max_requests:
            self.requests.append(now)
            return True

        return False
</code></pre>
<hr />
<h2 id="data-transformation">Data Transformation</h2>
<h3 id="api-response-application-models">API Response → Application Models</h3>
<pre><code class="language-python">from dataclasses import dataclass
from typing import List
from datetime import datetime

@dataclass
class CurrentWeather:
    &quot;&quot;&quot;Current weather conditions&quot;&quot;&quot;
    temperature: float  # In °C or °F
    apparent_temperature: float
    humidity: int  # 0-100
    weather_code: int
    wind_speed: float
    wind_direction: int  # 0-360 degrees
    wind_gust: float
    uv_index: float
    cloud_cover: int  # 0-100
    pressure: float  # hPa
    visibility: float  # meters
    timestamp: datetime

@dataclass
class HourlyData:
    &quot;&quot;&quot;Single hour of forecast data&quot;&quot;&quot;
    time: datetime
    temperature: float
    humidity: int
    precipitation: float
    weather_code: int
    wind_speed: float
    wind_direction: int

@dataclass
class DailyData:
    &quot;&quot;&quot;Single day of forecast data&quot;&quot;&quot;
    date: datetime
    temp_max: float
    temp_min: float
    precipitation: float
    weather_code: int

class WeatherTransformer:
    &quot;&quot;&quot;Transform API response to application models&quot;&quot;&quot;

    @staticmethod
    def transform_current(api_response: dict,
                         temperature_unit: str) -&gt; CurrentWeather:
        &quot;&quot;&quot;Extract current weather from API response&quot;&quot;&quot;

        hourly = api_response[&quot;hourly&quot;]
        # Use first entry (current time)
        current_data = {
            key: values[0]
            for key, values in hourly.items()
        }

        return CurrentWeather(
            temperature=current_data[&quot;temperature_2m&quot;],
            apparent_temperature=current_data[&quot;apparent_temperature&quot;],
            humidity=current_data[&quot;relative_humidity_2m&quot;],
            weather_code=current_data[&quot;weather_code&quot;],
            wind_speed=current_data[&quot;wind_speed_10m&quot;],
            wind_direction=current_data[&quot;wind_direction_10m&quot;],
            wind_gust=current_data.get(&quot;wind_gusts_10m&quot;, 0),
            uv_index=current_data[&quot;uv_index&quot;],
            cloud_cover=current_data[&quot;cloud_cover&quot;],
            pressure=current_data[&quot;pressure_msl&quot;],
            visibility=current_data.get(&quot;visibility&quot;, 10000),
            timestamp=datetime.now()
        )

    @staticmethod
    def transform_hourly(api_response: dict) -&gt; List[HourlyData]:
        &quot;&quot;&quot;Extract 24-hour forecast from API response&quot;&quot;&quot;

        hourly = api_response[&quot;hourly&quot;]
        times = [datetime.fromisoformat(t) for t in hourly[&quot;time&quot;][:24]]

        hourly_data = []
        for i, time in enumerate(times):
            hourly_data.append(HourlyData(
                time=time,
                temperature=hourly[&quot;temperature_2m&quot;][i],
                humidity=hourly[&quot;relative_humidity_2m&quot;][i],
                precipitation=hourly[&quot;precipitation&quot;][i],
                weather_code=hourly[&quot;weather_code&quot;][i],
                wind_speed=hourly[&quot;wind_speed_10m&quot;][i],
                wind_direction=hourly[&quot;wind_direction_10m&quot;][i]
            ))

        return hourly_data

    @staticmethod
    def transform_daily(api_response: dict) -&gt; List[DailyData]:
        &quot;&quot;&quot;Extract 7-day forecast from API response&quot;&quot;&quot;

        daily = api_response[&quot;daily&quot;]
        times = [datetime.fromisoformat(t).date() for t in daily[&quot;time&quot;][:7]]

        daily_data = []
        for i, date in enumerate(times):
            daily_data.append(DailyData(
                date=date,
                temp_max=daily[&quot;temperature_2m_max&quot;][i],
                temp_min=daily[&quot;temperature_2m_min&quot;][i],
                precipitation=daily[&quot;precipitation_sum&quot;][i],
                weather_code=daily[&quot;weather_code&quot;][i]
            ))

        return daily_data
</code></pre>
<hr />
<h2 id="integration-example">Integration Example</h2>
<p>Complete example of fetching and displaying weather:</p>
<pre><code class="language-python"># In weather_service.py

class WeatherService:
    def __init__(self, api_client: APIClient, cache: CacheManager):
        self.api_client = api_client
        self.cache = cache

    def get_weather(self, location: Location) -&gt; dict:
        &quot;&quot;&quot;
        Fetch weather for location with caching

        Example:
            &gt;&gt;&gt; service = WeatherService(api_client, cache)
            &gt;&gt;&gt; weather = service.get_weather(
            ...     Location(&quot;Delhi&quot;, 28.6139, 77.2090)
            ... )
            &gt;&gt;&gt; print(f&quot;Current: {weather['current'].temperature}°C&quot;)
        &quot;&quot;&quot;

        location_key = f&quot;{location.latitude}_{location.longitude}&quot;

        # Try cache first
        cached = self.cache.get(location_key)
        if cached:
            return self._format_response(cached, location)

        try:
            # Fetch from API
            raw_response = self.api_client.fetch_forecast(
                latitude=location.latitude,
                longitude=location.longitude,
                hourly_vars=HOURLY_VARIABLES,
                daily_vars=DAILY_VARIABLES,
                timezone=location.timezone
            )

            # Transform data
            weather_data = {
                &quot;current&quot;: WeatherTransformer.transform_current(raw_response),
                &quot;hourly&quot;: WeatherTransformer.transform_hourly(raw_response),
                &quot;daily&quot;: WeatherTransformer.transform_daily(raw_response),
                &quot;location&quot;: location,
                &quot;timestamp&quot;: datetime.now(),
                &quot;raw&quot;: raw_response
            }

            # Cache for next time
            self.cache.set(location_key, weather_data)

            return self._format_response(weather_data, location)

        except APIError as e:
            logger.error(f&quot;Failed to fetch weather: {e}&quot;)

            # Try stale cache
            stale_data, is_expired = self.cache.get_with_expiry(location_key)
            if stale_data:
                logger.info(&quot;Using stale cached data&quot;)
                return self._format_response(stale_data, location, stale=True)

            # No cache available
            raise WeatherFetchError(
                f&quot;Failed to fetch weather: {e}\n&quot;
                &quot;Please check your internet connection.&quot;
            )

    def _format_response(self, data: dict, location: Location,
                        stale: bool = False) -&gt; dict:
        &quot;&quot;&quot;Format weather data for UI&quot;&quot;&quot;
        return {
            &quot;current&quot;: data[&quot;current&quot;],
            &quot;hourly&quot;: data[&quot;hourly&quot;],
            &quot;daily&quot;: data[&quot;daily&quot;],
            &quot;location&quot;: location,
            &quot;is_stale&quot;: stale
        }
</code></pre>
<hr />
<h2 id="error-codes-status-codes">Error Codes &amp; Status Codes</h2>
<h3 id="http-status-codes">HTTP Status Codes</h3>
<table>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>Success, process response</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>Invalid parameters, check coordinates</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>API key issue (not applicable for Open-Meteo)</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests</td>
<td>Rate limited, implement backoff</td>
</tr>
<tr>
<td>500-599</td>
<td>Server Error</td>
<td>Temporary failure, retry later</td>
</tr>
</tbody>
</table>
<h3 id="custom-error-codes">Custom Error Codes</h3>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
<th>Recovery</th>
</tr>
</thead>
<tbody>
<tr>
<td>NETWORK_ERROR</td>
<td>No internet connection</td>
<td>Show offline mode, use cache</td>
</tr>
<tr>
<td>API_TIMEOUT</td>
<td>Request took too long</td>
<td>Retry with longer timeout</td>
</tr>
<tr>
<td>INVALID_RESPONSE</td>
<td>Malformed API response</td>
<td>Log error, use cached data</td>
</tr>
<tr>
<td>LOCATION_NOT_FOUND</td>
<td>Location search returned no results</td>
<td>Show error, try different search</td>
</tr>
<tr>
<td>CACHE_CORRUPTED</td>
<td>Cache file is invalid</td>
<td>Clear cache, fetch fresh</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>This documentation provides comprehensive API integration details for both users and developers.</strong></p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>